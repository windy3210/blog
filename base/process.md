## 什么是进程

进程是计算机分配资源的最小单位。是对程序运行时的一种抽象。



## 中断

64    31  大家都认可的中断

中断号 0x084

1 中断请求

2 中断响应

3 保存现场

4 中断处理			中断表。 整形   ->  函数地址

5 恢复现场





### 软中断

程序产生

fork



### 硬中断

硬件产生





## 进程是如何实现的

进程依赖中断来实现，同时IO、进程、虚拟内存管理都依赖中断。或者叫异常控制 ECF



## 程序的装入

程序从磁盘加载到内存执行的过程：



### 绝对装入

在编译时，如果知道程序将驻留在内存的什么位置，那么，编译程序将产生绝对地址 的目标代码。由于程序中的逻辑地址与实际内存地址完 全相同，故不须对程序和数据的地址进行修改。绝对地址可以在编译连接时候就给出，也可在程序中采用符号地址， 然后在编译或汇编时，再将这些符号地址转换为绝对地址。

事实上这只能在早期单道处理上用到，多道处理环境下编译器不可能知道编译的代码段将存储在内存的那个地址。

### 可重定位装入

在多道程序环境下，所得到的目标模块的起始地址通常是从 0 开始的，程序中的其它地址也都是相对于起始地址计算的。此时应采用可重定位装入方式，根据内存的当前情况，将装入模块装入到内存的适当位置。

即所有的地址都是相对于起始地址而言的 （起始 + 相对地址）但是它在运行时内存中的地址是不可变得。

### 动态运行时装入方式

动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址 转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存 后的所有地址都仍是相对地址。为使地址转换不影响指令的执行速度，这种方式需要一个 重定位寄存器的支持。

## 程序的链接

### 静态链接

在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完 整的装配模块，以后不再拆开。我们把这种事先进行链接的方式称为静态链接方式。

### 装入时动态链接

这是指将用户源程序编译后所得到的一组目标模块，在装入内存 时，采用边装入边链接的链接方式。

### 运行时动态链接

这是指对某些目标模块的链接，是在程序执行中需要该(目标)模 块时，才对它进行的链接。

## 内存连续分配

### 单一连续分配

采用这 种存储管理方式时，可把内存分为系统区和用户区两部分，系统区仅提供给 OS 使用，通常 是放在内存的低址部分;用户区是指除系统区以外的全部内存空间，提供给用户使用。

### 固定分区分配

固定分区式分配是最简单的一种可运行多道程序的存储管理方式。这是将内存用户空 间划分为若干个固定大小的区域，在每个分区中只装入一道作业，这样，把用户空间划分 为几个分区，便允许有几道作业并发运行。当有一空闲分区时，便可以再从外存的后备作 业队列中选择一个适当大小的作业装入该分区，当该作业结束时，又可再从后备作业队列 中找出另一作业调入该分区。



### 动态分区分配

为了实现分区分配，系统中必须配置相应的数据结构，用来描述空闲分区和已分配分 区的情况，为分配提供依据此时系统要维护动态分区链或分区表。



#### 首次适应算法(first fit)

在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要 求的空闲分区为止;然后再按照作业的大小，从该分区中划出一块内存空间分配给请求者， 余下的空闲分区仍留在空闲链中。若从链首直至链尾都不能找到一个能满足要求的分区， 则此次内存分配失败，返回。



##### 优点

倾向于优先利用内存中**低址部分**的空闲分区，从而保 留了**高址部分的大空闲区**。这给为以后到达的大作业分配大的内存空间创造了条件。



##### 缺点

点是低址部分不断被划分，会留下许多难以利用的、很小的空闲分区，而每次查找又都是 从低址部分开始，这无疑会增加查找可用空闲分区时的开销。



#### 循环首次适应算法(next fit)

在为进程分配内存空间时，不再是每次都从链 首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满 足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。

##### 优点

该算法能使内存中的空闲分区分布得 更均匀，从而减少了查找空闲分区时的开销，

##### 缺点

会缺乏大的空闲分区。

#### 最佳适应算法(best fit)

“最佳”是指每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区 分配给作业，避免“大材小用”。为了加速寻找，该算法要求将所有的空闲分区按其容量以 从小到大的顺序形成一空闲分区链。第一次找到的能满足要求的空闲区，必然是最佳的。

##### 优点

最佳适应算法似乎是最佳的，可以极大提升空间的利用率

##### 缺点

会留下大量的外部碎片，同时维护有序的空闲分区表也是不小的开销

#### 最坏适应算法(worst fit)

扫描整个空闲分区表或链表，挑选一个最大的空闲区分割给 作业使用

##### 优点

可使剩下的空闲区不至于太小，产生碎片的机率最小，对中、小作业 有利，同时最坏适应分配算法查找效率很高。该算法要求将所有的空闲分区按其容量以从 大到小的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。

##### 缺点

会使存储器中缺乏大的空闲分区。最坏适应算法与前面所述的首 次适应算法、循环首次适应算法、最佳适应算法一起，也称为顺序搜索法。

#### 快速适应算法(quick fit)

该算法又称为分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有 相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，系统中存在多个空闲分区 链表，同时在内存中设立一张管理索引表，该表的每一个表项对应了一种空闲分区类型， 并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进 行划分，如 2 KB、4 KB、8 KB 等，对于其它大小的分区，如 7 KB 这样的空闲区，既可以 放在 8 KB 的链表中，也可以放在一个特殊的空闲区链表中。

##### 优点

是查找效率高，仅需要根据进程的长度，寻找到能容纳它的最小空闲区 链表，并取下第一块进行分配即可。另外该算法在进行空闲分区分配时，不会对任何分区 产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。

##### 缺点

在分区归还主存时算法复杂，系统开销较大。此外，该算法在分配空 闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中， 或多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重，整体上会造成可观的存 储空间浪费，这是典型的以空间换时间的作法。



### 可重定位分区分配

在连续分配方式中，必须把一个系统或用户程序装入一连续的内存空间。但是剩下的若干个小的分区，即使它们容量的总和大于要装入的程序，但由于这些分区不相邻 接，也无法把该程序装入内存。

在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转换为物理地址的工作，推迟到程序指令要真正执行时进行。为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，即须在系统中增设一个重定位 寄存器，用它来存放程序(数据)在内存中的起始地址。

##### 实现

程序在执行时，真正访问的内存地址 是相对地址与重定位寄存器中的地址相加而形成的。 地址变换过程是在程序执行期间，随着对每条指令或数据的访问自动进行的，故称为动态 重定位。当系统对内存进行了“紧凑”而使若干程序从内存的某处移至另一处时，不需对 程序做任何修改，只要用该程序在内存的新起始地址，去置换原来的起始地址即可。

![image-20200525162611010](mem2.png)





#### 算法

动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于:在这种分配 算法中，增加了紧凑的功能，通常，在找不到足够大的空闲分区来满足用户需求时进行紧 凑。下图给出了动态重定位分区分配算法。

![image-20200525162808313](me2.png)

### 交换(sawp)



#### 为何使用交换

当某个进程被阻塞时，该程序所占用的内存是可以被让出的，因为在阻塞过程中这些数据不会被访问到。`交换`是指把内存中暂时不能 运行的进程或者暂时不用的程序和数据调出到外存上，以便腾出足够的内存空间，再把已 具备运行条件的进程或进程所需要的程序和数据调入内存。对换是提高内存利用率的有效 措施。



#### 交换的分类

`进程交换`:   这种对换被 广泛地应用于分时系统中，其目的是用来解决内存紧张问题，并可进一步提高内存的利用 率。

`页面交换`：以“页”为单位进行的，则分别称之为“页面对换”

`分段交换`：以“段”为单位进行交换，称为“分段交换”。

*tips：为了实现进程对换，系统必须能实现三方面的功能: 对换空间的管理、进程的换出，以及进程的换入。*



#### 对换空间的管理

通常外存会被分为`文件区`和`对换区`。前者用于存放文件，后者 用于存放从内存换出的进程。进程在对换区中驻留的时间是短暂的，对换操作又较频繁，对换空间管理的主要目标， 是提高进程换入和换出的速度，不必考虑空间开销因此采取的是连续分配方式，较少考虑外存中的碎片 问题。

为了能对对换区中的空闲盘块进行管理，在系统中应配置相应的数据结构，以记录外 存的使用情况。其形式与内存在动态分区分配方式中所用数据结构相似，即同样可以用空 闲分区表或空闲分区链。在空闲分区表中的每个表目中应包含两项，即对换区的首址及其 大小，分别用盘块号和盘块数表示。

对换空间的分配与回收，与动态分区 方式时的内存分配与回收方法类似。可以是首次适应算法、循环首次适应算法 或最佳适应算法。

#### 进程的换出与换入



##### 进程的换出

系统首先选择处于阻塞状态且优 先级最低的进程作为换出进程，然后启动磁盘，将该进程的程序和数据传送到磁盘的对换 区上。若传送过程未出现错误，便可回收该进程所占用的内存空间，并对该进程的进程控 制块做相应的修改。



##### 进程的换入

系统应定时地查看所有进程的状态，从中找出“就绪”状态但已换出 的进程，将其中换出时间最久(换出到磁盘上)的进程作为换入进程，将之换入，直至已无可 换入的进程或无可换出的进程为止。



![](process_virtual_memory.png)





## 进程特点

独立性：不同的进程各自独立的工作在自己所拥有的资源上，不会影响其他进程

动态性：动态的创建和消亡

并发性：进程可以被独立的调度，占用处理机完成作业

制约性：进程之间访问共享资源或进程同步会存在制约。





## 进程表

为了实现进程模型，操作系统维护着一张表格(一个结构数组)，即进程表。

每个进程占有一个进程表项。每个表项指向一个进程控制块PCB。



##  进程控制块（PCB）

`进程控制块是进程存在的唯一标识。而不是pid！！！`， 一般的因为它可以被动态的创建和消除，因此采用链表的数据结构来存储PCB方便随机的进行删除和插入。

不同状态的PCB组成不同的链表



### 进程标识信息

例如父进程ID、用户ID、进程ID等等



### 处理机状态信息

保存进程运行的现场

1 用户可见寄存器：用户可以使用的地址、地址等寄存器信息

2 控制和状态寄存器：程序计数器、程序状态字等信息

3 栈指针：过程调用、系统调用、中断处理和返回需要通过栈来确定现场。



### 进程控制信息

调度和状态信息：操作系统调度进程和占用处理机使用的信息

进程间通信信息：存放进程间通信的标识、信号等信息

存储管理信息：包含该进程指向存储空间中的数据结构

进程所用资源：该进程使用的系统资源例如文件、外设等

相关数据结构链接信息：进程可以链接到任务队列中或其他进程的PCB中



## 进程调度

操作系统使用状态队列对进程的状态来进行管理

操作系统通过维护一组队列来表示当前系统中所有进程的当前状态。

不同的状态使用不同的队列存储（存储的是`PCB`）. process control block

当状态发生变化时，将该`PCB`转移到相应的队列中去。

### 1 先来先去服务

先来先去服务调度算法是一种最简单的调度算法，也称为先进先出或严格排队方案。当每个进程就绪后，它加入就绪队列。当前正运行的进程停止执行，选择在就绪队列中存在时间最长的进程运行。该算法既可以用于作业调度，也可以用于进程调度。先来先去服务比较适合于常作业（进程），而不利于段作业（进程）。

### 2 时间片轮转法

轮转法是基于适中的抢占策略的，以一个周期性间隔产生时钟中断，当中断发生后，当前正在运行的进程被置于就绪队列中，然后基于先来先去服务策略选择下一个就绪作业的运行。这种技术也称为时间片，因为每个进程再被抢占之前都给定一片时间。

### 3 最短进程优先

最短进程优先是一个非抢占策略，他的原则是下一次选择预计处理时间最短的进程，因此短进程将会越过长作业，跳至队列头。该算法即可用于作业调度，也可用于进程调度。但是他对长作业不利，不能保证紧迫性作业（进程）被及时处理，作业的长短只是被估算出来的。

### 4 最短剩余时间优先

最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。

### 5 最高响应比优先

根据比率：R=(w+s)/s （R为响应比，w为等待处理的时间，s为预计的服务时间）

如果该进程被立即调用，则R值等于归一化周转时间（周转时间和服务时间的比率）。R最小值为1.0，只有第一个进入系统的进程才能达到该值。调度规则为：当前进程完成或被阻塞时，选择R值最大的就绪进程，它说明了进程的年龄。当偏向短作业时，长进程由于得不到服务，等待时间不断增加，从而增加比值，最终在竞争中赢了短进程。

和最短进程优先、最短剩余时间优先一样，使用最高响应比策略需要估计预计服务时间。



### 6 反馈法

　　如果没有关于进程相对长度的任何信息，则最短进程优先，最短剩余时间、最高响应优先比都不能使用。另一种导致偏向短作业的方法是处罚运行时间较长的作业，换句话说，如果不能获得剩余的执行时间，那就关注已执行了的时间。

　　方法为：调度基于被抢占原则（按时间片）并使用动态优先级机制。当一个进程第一次进入系统中时，他被放置在一个优先级队列中，当第一次被抢占后并返回就绪状态时，它被放置在下一个低优先级队列中，在随后的时间里，每当被抢占时，他被降级到下一个低优先级队列中。一个短进程很快被执行完，不会在就绪队列中降很多级，一个长进程会逐渐降级。因此先到的进程和短进程优先于长进程和老进程。在每个队列中，除了优先级在最低的队列中之外，都是用简单的先来先去服务机制，一旦一个进程处于优先级最低的队列中，它就不可能在降级，但会重复的返回该队列，直到运行结束。因此，该队列课按照轮转方式调度。



### 7 多级反馈队列调度算法

　　多级反馈队列算法，不必事先知道各种进程所需要执行的时间，他是当前被公认的一种较好的进程调度算法。其实施过程如下：

- 设置多个就绪队列，并为各个队列赋予不同的优先级。在优先权越高的队列中，为每个进程所规定的执行时间片就越小。

- 当一个新进程进入内存后，首先放入第一队列的末尾，按照先来先去原则排队等候调度。如果他能在一个时间片中完成，便可撤离；如果未完成，就转入第二队列的末尾，同样等待调度.....如此下去，当一个长作业（进程）从第一队列依次将到第n队列（最后队列）后，便按第n队列时间片轮转运行。

- 仅当第一队列空闲的时候，调度程序才调度第二队列中的进程运行；仅当第1到（i-1）队列空时，才会调度第i队列中的进程运行，并执行相应的时间片轮转。

- 如果处理机正在处理第i队列中某进程，又有新进程进入优先权较高的队列，则此新队列抢占正在运行的处理机，并把正在运行的进程放在第i队列的队尾。



## 进程状态转换

在不考虑挂起的情况下有五种状态，创建、就绪、阻塞、运行、终止



### 五状态转换

![img](process_five_status.png)



### 挂起与激活

某个进程处在阻塞态时，进程会占用内存空间，这是一种浪费行为，于是操作系统会有跟内存管理中物理页置换到磁盘一样的行为，把阻塞的进程置换到磁盘中，让出物理内存，此时进程未占用物理内存，这种状态称为**挂起**。

挂起不仅仅可能是物理内存不足，比如sleep系统调用过着用户执行CtrI+Z也可能导致挂起。



#### 阻塞 —> 阻塞挂起

没有进程处于就绪状态或就绪进程要求更多的资源时（更多时候指主存资源）。会进行这样的转换，以待新的进程或运行就绪进程。



#### 就绪 —> 就绪挂起

当存在高优先级阻塞（系统认为很快就绪的）和低优先级就绪进程时优先选择挂起低优先级进程。



#### 运行 —> 就绪挂起

对于抢占式分时系统来说，当有高优先级的阻塞挂起进程变为就绪挂起时，系统会将正在运行的进程转化为就绪挂起。



#### 阻塞挂起 —> 就绪挂起(发生在外存)

当阻塞挂起的进程等待的事件发生，会将阻塞挂起状态转为 就绪挂起状态



#### 就绪挂起 —> 就绪

没有就绪进程或就绪进程优先级小于就绪挂起进程的优先级，会进行这样的转化。



#### 阻塞挂起 —> 阻塞

当一个进程释放了很大的内存时，系统会将一个高优先级阻塞挂起进程转化为阻塞进程。没





### 七状态转化

考虑挂起的情况下有七种



![img](process_seven_status.png)



## 特殊进程

### 守护进程

指在后**台运行且没有控制终端**的进程。它独立于控制终端，周期性地执行某种任务。

Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等。通常他们都是以d结尾，例如 mysqld。



### 僵尸进程

多进程程序，父进程一般需要跟踪子进程的退出状态，当子进程退出，父进程在运行，子进程必须等到父进程捕获
到了子进程的退出状态才真正结束。在子进程结束后，父进程读取状态前，此时子进程为僵尸进程。

设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终
止状态，以及该进程使用的CPU时间。所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。
但是子进程停止在僵尸态会占据内核资源，所以需要避免僵尸进程的产生或立即结束子进程的僵尸态。



#### 避免僵尸进程

- 父进程调用wait/waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞。waitpid只会
    等待由pid参数指定的子进程，同时也是非阻塞，目标进程正常退出返回子进程PID,还没结束返回0。

- 在事件已经发生情况下执行非阻塞调用可以提高程序效率。对waitpid, 最好在子进程退出后调用。使用
    SIGCHLD信号通知父进程，子进程结束。
    父进程中捕获信号， 然后在信号处理函数中调用waitpid以彻底结束子进程

- 通过signal(SIGCHLD, SIG_ IGN)通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以
    在父进程中加入一条语句: signal(SIGCHLD,SIG_ IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的
    时候向父进程发送的。

- 忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终
    结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给
    init进程去处理，省去了大量僵尸进程占用系统资源。



### 孤儿进程

父进程如果不等待子进程退出，在子进程之前就结束了自己的“生命”，此时子进程就叫做孤儿进程。
Linux避免系统存在过多孤儿进程，init进程收留孤儿进程，变成孤儿进程的父进程。

> pid==1的进程称为init进程也就是初始化进程



### 创建守护进程

1. 创建子进程，父进程退出(必须)

    1.   fork() 函数
    2.   所有工作在子进程中进行形式上脱离了控制终端

2. 在子进程中创建新会话(必须)

    1.   setsid()函数
    2.   使子进程完全独立出来，脱离控制。

3. 改变当前目录为根目录(不是必须)

    1.   chdir(‘/’)函数
    2.   防止占用可卸载的文件系统也可以换成其它路径

4. 重设文件权限掩码(不是必须)

    1.   umask(0)函数
    2.   防止继承的文件创建屏蔽字拒绝某些权限增加守护进程灵活性

5. 关闭文件描述符(不是必须)

    1.   继承的打开文件不会用到，浪费系统资源，无法卸载，

6. 开始执行守护进程核心工作(必须)
    守护进程退出处理程序模型

7. 处理SIGCHLD信号(不是必须)。

    对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待父进程捕获状态，则子进程将成为僵尸
    进程(zombie) ， 从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并
    发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_ IGN。这样，子进程结束时不会产生僵尸进程。

> Python 语言描述构建一个守护进程的过程。

```python
import os
import signal
import time


def create_daemon_process() -> None:
    pid: int = os.fork()

    if pid > 0:
        exit(0)

    if pid == 0:
        os.setsid()   # to be session master
        os.chdir(os.sep)   # adjust work directory
        os.umask(0)  # changed umask
        daemod_pid: int = os.fork()
        if daemod_pid > 0:
            exit(0)  # exit middle process
        
        if daemod_pid == 0:
            # ignore child exit signal
            signal.signal(signal.SIGCHLD, signal.SIG_IGN)
            while True:
                print("current process is daemon process")
                time.sleep(10)
        if daemod_pid < 0:
            print("create daemon failed!")

```



(1)让程序在后台执行。
方法是调用fork()产生一个子进程，然后使父进程退出。.

(2)调用setsid()创建一 个新对话期。
守护进程需要摆脱父进程的影响，方法是调用setsid()使进程成为一一个会话组长。setsid()调用 成功后，进程成为新
的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。

(3)禁止进程重新打开控制终端。
经过1和2，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可
以通过使进程不再是会话组长来实现。再一次通过fork ()创建新的子进程，使调用fork的进程退出。

(4)关闭不再需要的文件描述符。
子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引
起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描
述符。

(5)将当前目录更改为根目录。

(6)子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask(0)将权限屏蔽字清零。




## 进程的内存分布

#### 全局区（静态区）

存放全局变量、静态数据，const常量。程序结束后有系统释放

#### 栈区（stack）

函数运行时分配，函数结束时释放。由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈。

#### 堆区（heap）

一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS（操作系统）回收。分配方式类似于链表。

#### 常量区

常量字符串就是放在这里的。 程序结束后由系统释放。

#### 程序代码区

存放函数体（类成员函数和全局函数）的二进制代码。



<img src="process_virtual_memory.png" style="zoom:40%;" />



## 进程间通信

### 1 无名管道

1、特点
1.半双工，数据在同一时刻只能在一个方向上流动
2.数据只能从管道的一端写入，从另- -端读出
3.写入管道中的数据遵循先入先出的规则
4.管道所传送的数据是无格式的，这要求管道的读出方与写入方必须事先约定好数据的格式，如多少字节算一个
消息等
5.管道不是普通的文件，不属于某个文件系统，其只存在于内存中
6.管道在内存中对应一个缓冲区。不同的系统其大小不一-定相同.
7.从管道读数据是一次性操作， 数据一旦被读走，它就从管道中被拋弃，释放空间以便写更多的数据
8.管道没有名字，只能在具有公共祖先的进程(父进程与子进程，或者两个兄弟进程，具有亲缘关系)之间使用
9.存在阻塞方式



### 2 命名管道

命名管道(FIFO) 不同于无名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信，因此，通过FIFO不相关的进程也能交换数据。

> 与无名管道(pipe)不同

1. FIFO在文件系统中作为一个特殊的文件而存在，但FIFO中的内容却存放在内存中;
2. 当使用FIFO的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用;
3. FIFO有名字，不相关的进程可以通过打开命名管道进行通信.





### 3 共享存储映射（mmap）

存储映射I/O (Memory-mapped I/O)使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址(指针)完成I/O操作，进程就可以直接通过读写内存来操作文件共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式,因为进程可以直接读写内存，而不需要任何数据的拷贝。



### 4 消息队列

#### 基本原理

A进程要给B进程发送消息，A进程把数据放在对应的消息队列后就可以正常返回了，B进程需要的时
候再去读取数据就可以了。

#### 特点

- 消息队列是保存在内核中的消息链表，每个消息体都是固定大小的存储块。如果进程从消息队列中读取了消息
    体，内核就会把这个消息体删除。
- 如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。

#### 缺点

- 通信不及时，附件也有大小限制。
- 消息队列不适合比较大数据的传输，每个消息体都有-个最大长度的限制，同时所有队列所包含的全部消息体
    的总长度也是有上限
- 消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销



### 5 信号

信号是linux进程通信的最古老的方式，信号是软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发 事件。
信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了哪些系统事件。



#### 信号的特点

- 简单
- 不能携带大量信息
- 满足某个特定条件才发送
- 一个完整的信号周期



#### 信号的产生

信号在进程种的注册，信号在进程种的注销

执行信号处理函数

信号编号

(1)不存在编号为0的信号
1.其中1-31号信号称之为常规信号(也叫普通信号或标准信号)
2.34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同
(2)不存在编号为0的号，也没有32-33号

(3)比较重要的一些，需要记住的几个信号

1. SIGINT当用户按下了<Ctrl+C>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号，终止进
    程
2. SIGQUIT 用户按下<ctrl+>组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号,终
    止进程
3. SIGSEGV 指示进程进行了无效内存访问(段错误),终止进程并产生core文件
4. SIGPIPE Broken pipe向一一个没有读端的管道写数据,终止进程
5. SIGCHLD 子进程结束时，父进程会收到这个信号,忽略这个信号
    4、信号四要素
    (1)编号: man 7 signal查看文档帮助
    (2)名称
    (3)事件
    (4)默认处理动作:
6. Term:终止进程
7. Ign:忽略信号(默认即时对该种信号忽略操作)
8. Core: 终止进程，生成Core文件。(查验死亡原因，用于gdb调试)
9. Stop: 停止(暂停)进程
10. Cont:继续运行进程



特别强调: 9) SIGKILL和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞.
5、信号的状态
(1) 产生
1.当用户按某些终端键时，将产生信号
2.硬件异常将产生信号
3.软件异常将产生信号
4.调用系统函数(如: kill raise、 abort)将发送信号
5.运行kill /killall命令将发送信号
(2) 未决状态:没有被处理
(3)递达状态:信号被处理了
6、阻塞信号集和未决信号集
(1)阻塞信号集
将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(处理发生在解除屏
蔽后)
(2) 未决信号集合
信号产生，未决信号集中描述该信号的位立刻翻转为1,表示信号处于未决状态。当信号被处理对应位翻转回为0。
这一时刻往往非常短暂.
